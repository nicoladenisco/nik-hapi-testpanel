package ca.uhn.hl7v2.testpanel.ui;

import java.awt.BorderLayout;
import java.io.File;
import java.util.Date;
import javax.swing.UIManager;
import javax.swing.event.TreeModelListener;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreePath;
import org.netbeans.swing.outline.DefaultOutlineModel;
import org.netbeans.swing.outline.Outline;
import org.netbeans.swing.outline.OutlineModel;
import org.netbeans.swing.outline.RenderDataProvider;
import org.netbeans.swing.outline.RowModel;

/**
 *
 * @author Nicola De Nisco
 */
public class TestOutlineFrame extends javax.swing.JFrame
{
  private Outline outline;

  /** Creates new form TestOutlineFrame */
  public TestOutlineFrame()
  {
    initComponents();

    setLayout(new BorderLayout());
    TreeModel treeMdl = new FileTreeModel(new File("/home/nicola"));

    OutlineModel mdl = DefaultOutlineModel.createOutlineModel(treeMdl,
       new FileRowModel(), true);
    outline = new Outline();
    outline.setRenderDataProvider(new FileDataProvider());
    outline.setRootVisible(true);
    outline.setModel(mdl);
    add(outline, BorderLayout.CENTER);
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents()
  {

    setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 400, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 300, Short.MAX_VALUE)
    );

    pack();
  }// </editor-fold>//GEN-END:initComponents

  /**
   * @param args the command line arguments
   */
  public static void main(String args[])
  {
    try
    {
      for(javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels())
      {
        if("Nimbus".equals(info.getName()))
        {
          javax.swing.UIManager.setLookAndFeel(info.getClassName());
          break;
        }
      }
    }
    catch(ClassNotFoundException ex)
    {
      java.util.logging.Logger.getLogger(TestOutlineFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    catch(InstantiationException ex)
    {
      java.util.logging.Logger.getLogger(TestOutlineFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    catch(IllegalAccessException ex)
    {
      java.util.logging.Logger.getLogger(TestOutlineFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    catch(javax.swing.UnsupportedLookAndFeelException ex)
    {
      java.util.logging.Logger.getLogger(TestOutlineFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    //</editor-fold>

    /* Create and display the form */
    java.awt.EventQueue.invokeLater(new Runnable()
    {
      public void run()
      {
        new TestOutlineFrame().setVisible(true);
      }
    });
  }

  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables
  private class FileRowModel implements RowModel
  {
    public Class getColumnClass(int column)
    {
      switch(column)
      {
        case 0:
          return Date.class;
        case 1:
          return Long.class;
        default:
          assert false;
      }
      return null;
    }

    public int getColumnCount()
    {
      return 2;
    }

    public String getColumnName(int column)
    {
      return column == 0 ? "Date" : "Size";
    }

    public Object getValueFor(Object node, int column)
    {
      File f = (File) node;
      switch(column)
      {
        case 0:
          return new Date(f.lastModified());
        case 1:
          return new Long(f.length());
        default:
          assert false;
      }
      return null;
    }

    public boolean isCellEditable(Object node, int column)
    {
      return false;
    }

    public void setValueFor(Object node, int column, Object value)
    {
      //do nothing, nothing is editable
    }
  }

  private class FileDataProvider implements RenderDataProvider
  {
    public java.awt.Color getBackground(Object o)
    {
      return null;
    }

    public String getDisplayName(Object o)
    {
      return ((File) o).getName();
    }

    public java.awt.Color getForeground(Object o)
    {
      File f = (File) o;
      if(!f.isDirectory() && !f.canWrite())
      {
        return UIManager.getColor("controlShadow");
      }
      return null;
    }

    public javax.swing.Icon getIcon(Object o)
    {
      return null;
    }

    public String getTooltipText(Object o)
    {
      return ((File) o).getAbsolutePath();
    }

    public boolean isHtmlDisplayName(Object o)
    {
      return false;
    }
  }

  /**
   * The methods in this class allow the JTree component to traverse
   * the file system tree, and display the files and directories.
   * */
  class FileTreeModel implements TreeModel
  {
    // We specify the root directory when we create the model.
    protected File root;

    public FileTreeModel(File root)
    {
      this.root = root;
    }

    // The model knows how to return the root object of the tree
    public Object getRoot()
    {
      return root;
    }

    // Tell JTree whether an object in the tree is a leaf or not
    public boolean isLeaf(Object node)
    {
      return ((File) node).isFile();
    }

    // Tell JTree how many children a node has
    public int getChildCount(Object parent)
    {
      String[] children = ((File) parent).list();
      if(children == null)
        return 0;
      return children.length;
    }

    // Fetch any numbered child of a node for the JTree.
    // Our model returns File objects for all nodes in the tree.  The
    // JTree displays these by calling the File.toString() method.
    public Object getChild(Object parent, int index)
    {
      String[] children = ((File) parent).list();
      if((children == null) || (index >= children.length))
        return null;
      return new File((File) parent, children[index]);
    }

    // Figure out a child's position in its parent node.
    public int getIndexOfChild(Object parent, Object child)
    {
      String[] children = ((File) parent).list();
      if(children == null)
        return -1;
      String childname = ((File) child).getName();
      for(int i = 0; i < children.length; i++)
      {
        if(childname.equals(children[i]))
          return i;
      }
      return -1;
    }

    // This method is only invoked by the JTree for editable trees.
    // This TreeModel does not allow editing, so we do not implement
    // this method.  The JTree editable property is false by default.
    public void valueForPathChanged(TreePath path, Object newvalue)
    {
    }

    // Since this is not an editable tree model, we never fire any events,
    // so we don't actually have to keep track of interested listeners.
    public void addTreeModelListener(TreeModelListener l)
    {
    }

    public void removeTreeModelListener(TreeModelListener l)
    {
    }
  }

}
